// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package pulumiservice

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-pulumiservice/sdk/go/pulumiservice/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// A scheduled stack destroy run.
type TtlSchedule struct {
	pulumi.CustomResourceState

	// True if the stack and all associated history and settings should be deleted. Defaults to false, which means only the resources are destroyed but the stack itself remains.
	DeleteAfterDestroy pulumi.BoolPtrOutput `pulumi:"deleteAfterDestroy"`
	// Organization name.
	Organization pulumi.StringOutput `pulumi:"organization"`
	// Project name.
	Project pulumi.StringOutput `pulumi:"project"`
	// Schedule ID of the created schedule, assigned by Pulumi Cloud.
	ScheduleId pulumi.StringOutput `pulumi:"scheduleId"`
	// Stack name.
	Stack pulumi.StringOutput `pulumi:"stack"`
	// The time at which the schedule should run, in ISO 8601 format. Eg: 2020-01-01T00:00:00Z.
	Timestamp pulumi.StringOutput `pulumi:"timestamp"`
}

// NewTtlSchedule registers a new resource with the given unique name, arguments, and options.
func NewTtlSchedule(ctx *pulumi.Context,
	name string, args *TtlScheduleArgs, opts ...pulumi.ResourceOption) (*TtlSchedule, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Organization == nil {
		return nil, errors.New("invalid value for required argument 'Organization'")
	}
	if args.Project == nil {
		return nil, errors.New("invalid value for required argument 'Project'")
	}
	if args.Stack == nil {
		return nil, errors.New("invalid value for required argument 'Stack'")
	}
	if args.Timestamp == nil {
		return nil, errors.New("invalid value for required argument 'Timestamp'")
	}
	if args.DeleteAfterDestroy == nil {
		args.DeleteAfterDestroy = pulumi.BoolPtr(false)
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource TtlSchedule
	err := ctx.RegisterResource("pulumiservice:index:TtlSchedule", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetTtlSchedule gets an existing TtlSchedule resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetTtlSchedule(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *TtlScheduleState, opts ...pulumi.ResourceOption) (*TtlSchedule, error) {
	var resource TtlSchedule
	err := ctx.ReadResource("pulumiservice:index:TtlSchedule", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering TtlSchedule resources.
type ttlScheduleState struct {
}

type TtlScheduleState struct {
}

func (TtlScheduleState) ElementType() reflect.Type {
	return reflect.TypeOf((*ttlScheduleState)(nil)).Elem()
}

type ttlScheduleArgs struct {
	// True if the stack and all associated history and settings should be deleted. Defaults to false, which means only the resources are destroyed but the stack itself remains.
	DeleteAfterDestroy *bool `pulumi:"deleteAfterDestroy"`
	// Organization name.
	Organization string `pulumi:"organization"`
	// Project name.
	Project string `pulumi:"project"`
	// Stack name.
	Stack string `pulumi:"stack"`
	// The time at which the schedule should run, in ISO 8601 format. Eg: 2020-01-01T00:00:00Z.
	Timestamp string `pulumi:"timestamp"`
}

// The set of arguments for constructing a TtlSchedule resource.
type TtlScheduleArgs struct {
	// True if the stack and all associated history and settings should be deleted. Defaults to false, which means only the resources are destroyed but the stack itself remains.
	DeleteAfterDestroy pulumi.BoolPtrInput
	// Organization name.
	Organization pulumi.StringInput
	// Project name.
	Project pulumi.StringInput
	// Stack name.
	Stack pulumi.StringInput
	// The time at which the schedule should run, in ISO 8601 format. Eg: 2020-01-01T00:00:00Z.
	Timestamp pulumi.StringInput
}

func (TtlScheduleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ttlScheduleArgs)(nil)).Elem()
}

type TtlScheduleInput interface {
	pulumi.Input

	ToTtlScheduleOutput() TtlScheduleOutput
	ToTtlScheduleOutputWithContext(ctx context.Context) TtlScheduleOutput
}

func (*TtlSchedule) ElementType() reflect.Type {
	return reflect.TypeOf((**TtlSchedule)(nil)).Elem()
}

func (i *TtlSchedule) ToTtlScheduleOutput() TtlScheduleOutput {
	return i.ToTtlScheduleOutputWithContext(context.Background())
}

func (i *TtlSchedule) ToTtlScheduleOutputWithContext(ctx context.Context) TtlScheduleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TtlScheduleOutput)
}

// TtlScheduleArrayInput is an input type that accepts TtlScheduleArray and TtlScheduleArrayOutput values.
// You can construct a concrete instance of `TtlScheduleArrayInput` via:
//
//	TtlScheduleArray{ TtlScheduleArgs{...} }
type TtlScheduleArrayInput interface {
	pulumi.Input

	ToTtlScheduleArrayOutput() TtlScheduleArrayOutput
	ToTtlScheduleArrayOutputWithContext(context.Context) TtlScheduleArrayOutput
}

type TtlScheduleArray []TtlScheduleInput

func (TtlScheduleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*TtlSchedule)(nil)).Elem()
}

func (i TtlScheduleArray) ToTtlScheduleArrayOutput() TtlScheduleArrayOutput {
	return i.ToTtlScheduleArrayOutputWithContext(context.Background())
}

func (i TtlScheduleArray) ToTtlScheduleArrayOutputWithContext(ctx context.Context) TtlScheduleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TtlScheduleArrayOutput)
}

// TtlScheduleMapInput is an input type that accepts TtlScheduleMap and TtlScheduleMapOutput values.
// You can construct a concrete instance of `TtlScheduleMapInput` via:
//
//	TtlScheduleMap{ "key": TtlScheduleArgs{...} }
type TtlScheduleMapInput interface {
	pulumi.Input

	ToTtlScheduleMapOutput() TtlScheduleMapOutput
	ToTtlScheduleMapOutputWithContext(context.Context) TtlScheduleMapOutput
}

type TtlScheduleMap map[string]TtlScheduleInput

func (TtlScheduleMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*TtlSchedule)(nil)).Elem()
}

func (i TtlScheduleMap) ToTtlScheduleMapOutput() TtlScheduleMapOutput {
	return i.ToTtlScheduleMapOutputWithContext(context.Background())
}

func (i TtlScheduleMap) ToTtlScheduleMapOutputWithContext(ctx context.Context) TtlScheduleMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TtlScheduleMapOutput)
}

type TtlScheduleOutput struct{ *pulumi.OutputState }

func (TtlScheduleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TtlSchedule)(nil)).Elem()
}

func (o TtlScheduleOutput) ToTtlScheduleOutput() TtlScheduleOutput {
	return o
}

func (o TtlScheduleOutput) ToTtlScheduleOutputWithContext(ctx context.Context) TtlScheduleOutput {
	return o
}

// True if the stack and all associated history and settings should be deleted. Defaults to false, which means only the resources are destroyed but the stack itself remains.
func (o TtlScheduleOutput) DeleteAfterDestroy() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *TtlSchedule) pulumi.BoolPtrOutput { return v.DeleteAfterDestroy }).(pulumi.BoolPtrOutput)
}

// Organization name.
func (o TtlScheduleOutput) Organization() pulumi.StringOutput {
	return o.ApplyT(func(v *TtlSchedule) pulumi.StringOutput { return v.Organization }).(pulumi.StringOutput)
}

// Project name.
func (o TtlScheduleOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v *TtlSchedule) pulumi.StringOutput { return v.Project }).(pulumi.StringOutput)
}

// Schedule ID of the created schedule, assigned by Pulumi Cloud.
func (o TtlScheduleOutput) ScheduleId() pulumi.StringOutput {
	return o.ApplyT(func(v *TtlSchedule) pulumi.StringOutput { return v.ScheduleId }).(pulumi.StringOutput)
}

// Stack name.
func (o TtlScheduleOutput) Stack() pulumi.StringOutput {
	return o.ApplyT(func(v *TtlSchedule) pulumi.StringOutput { return v.Stack }).(pulumi.StringOutput)
}

// The time at which the schedule should run, in ISO 8601 format. Eg: 2020-01-01T00:00:00Z.
func (o TtlScheduleOutput) Timestamp() pulumi.StringOutput {
	return o.ApplyT(func(v *TtlSchedule) pulumi.StringOutput { return v.Timestamp }).(pulumi.StringOutput)
}

type TtlScheduleArrayOutput struct{ *pulumi.OutputState }

func (TtlScheduleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*TtlSchedule)(nil)).Elem()
}

func (o TtlScheduleArrayOutput) ToTtlScheduleArrayOutput() TtlScheduleArrayOutput {
	return o
}

func (o TtlScheduleArrayOutput) ToTtlScheduleArrayOutputWithContext(ctx context.Context) TtlScheduleArrayOutput {
	return o
}

func (o TtlScheduleArrayOutput) Index(i pulumi.IntInput) TtlScheduleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *TtlSchedule {
		return vs[0].([]*TtlSchedule)[vs[1].(int)]
	}).(TtlScheduleOutput)
}

type TtlScheduleMapOutput struct{ *pulumi.OutputState }

func (TtlScheduleMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*TtlSchedule)(nil)).Elem()
}

func (o TtlScheduleMapOutput) ToTtlScheduleMapOutput() TtlScheduleMapOutput {
	return o
}

func (o TtlScheduleMapOutput) ToTtlScheduleMapOutputWithContext(ctx context.Context) TtlScheduleMapOutput {
	return o
}

func (o TtlScheduleMapOutput) MapIndex(k pulumi.StringInput) TtlScheduleOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *TtlSchedule {
		return vs[0].(map[string]*TtlSchedule)[vs[1].(string)]
	}).(TtlScheduleOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*TtlScheduleInput)(nil)).Elem(), &TtlSchedule{})
	pulumi.RegisterInputType(reflect.TypeOf((*TtlScheduleArrayInput)(nil)).Elem(), TtlScheduleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TtlScheduleMapInput)(nil)).Elem(), TtlScheduleMap{})
	pulumi.RegisterOutputType(TtlScheduleOutput{})
	pulumi.RegisterOutputType(TtlScheduleArrayOutput{})
	pulumi.RegisterOutputType(TtlScheduleMapOutput{})
}
