// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package pulumiservice

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-pulumiservice/sdk/go/pulumiservice/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// A scheduled stack destroy run.
type TtlSchedule struct {
	pulumi.CustomResourceState

	// True if the stack and all associated history and settings should be deleted.
	DeleteAfterDestroy pulumi.BoolPtrOutput `pulumi:"deleteAfterDestroy"`
	// Organization name.
	Organization pulumi.StringOutput `pulumi:"organization"`
	// Project name.
	Project pulumi.StringOutput `pulumi:"project"`
	// Schedule ID of the created schedule, assigned by Pulumi Cloud.
	ScheduleId pulumi.StringOutput `pulumi:"scheduleId"`
	// Stack name.
	Stack pulumi.StringOutput `pulumi:"stack"`
	// The time at which the schedule should run, in ISO 8601 format. Eg: 2020-01-01T00:00:00Z.
	Timestamp pulumi.StringOutput `pulumi:"timestamp"`
}

// NewTtlSchedule registers a new resource with the given unique name, arguments, and options.
func NewTtlSchedule(ctx *pulumi.Context,
	name string, args *TtlScheduleArgs, opts ...pulumi.ResourceOption) (*TtlSchedule, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Organization == nil {
		return nil, errors.New("invalid value for required argument 'Organization'")
	}
	if args.Project == nil {
		return nil, errors.New("invalid value for required argument 'Project'")
	}
	if args.Stack == nil {
		return nil, errors.New("invalid value for required argument 'Stack'")
	}
	if args.Timestamp == nil {
		return nil, errors.New("invalid value for required argument 'Timestamp'")
	}
	if args.DeleteAfterDestroy == nil {
		args.DeleteAfterDestroy = pulumi.BoolPtr(false)
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource TtlSchedule
	err := ctx.RegisterResource("pulumiservice:index:TtlSchedule", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetTtlSchedule gets an existing TtlSchedule resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetTtlSchedule(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *TtlScheduleState, opts ...pulumi.ResourceOption) (*TtlSchedule, error) {
	var resource TtlSchedule
	err := ctx.ReadResource("pulumiservice:index:TtlSchedule", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering TtlSchedule resources.
type ttlScheduleState struct {
}

type TtlScheduleState struct {
}

func (TtlScheduleState) ElementType() reflect.Type {
	return reflect.TypeOf((*ttlScheduleState)(nil)).Elem()
}

type ttlScheduleArgs struct {
	// True if the stack and all associated history and settings should be deleted.
	DeleteAfterDestroy *bool `pulumi:"deleteAfterDestroy"`
	// Organization name.
	Organization string `pulumi:"organization"`
	// Project name.
	Project string `pulumi:"project"`
	// Stack name.
	Stack string `pulumi:"stack"`
	// The time at which the schedule should run, in ISO 8601 format. Eg: 2020-01-01T00:00:00Z.
	Timestamp string `pulumi:"timestamp"`
}

// The set of arguments for constructing a TtlSchedule resource.
type TtlScheduleArgs struct {
	// True if the stack and all associated history and settings should be deleted.
	DeleteAfterDestroy pulumi.BoolPtrInput
	// Organization name.
	Organization pulumi.StringInput
	// Project name.
	Project pulumi.StringInput
	// Stack name.
	Stack pulumi.StringInput
	// The time at which the schedule should run, in ISO 8601 format. Eg: 2020-01-01T00:00:00Z.
	Timestamp pulumi.StringInput
}

func (TtlScheduleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ttlScheduleArgs)(nil)).Elem()
}

type TtlScheduleInput interface {
	pulumi.Input

	ToTtlScheduleOutput() TtlScheduleOutput
	ToTtlScheduleOutputWithContext(ctx context.Context) TtlScheduleOutput
}

func (*TtlSchedule) ElementType() reflect.Type {
	return reflect.TypeOf((**TtlSchedule)(nil)).Elem()
}

func (i *TtlSchedule) ToTtlScheduleOutput() TtlScheduleOutput {
	return i.ToTtlScheduleOutputWithContext(context.Background())
}

func (i *TtlSchedule) ToTtlScheduleOutputWithContext(ctx context.Context) TtlScheduleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TtlScheduleOutput)
}

// TtlScheduleArrayInput is an input type that accepts TtlScheduleArray and TtlScheduleArrayOutput values.
// You can construct a concrete instance of `TtlScheduleArrayInput` via:
//
//	TtlScheduleArray{ TtlScheduleArgs{...} }
type TtlScheduleArrayInput interface {
	pulumi.Input

	ToTtlScheduleArrayOutput() TtlScheduleArrayOutput
	ToTtlScheduleArrayOutputWithContext(context.Context) TtlScheduleArrayOutput
}

type TtlScheduleArray []TtlScheduleInput

func (TtlScheduleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*TtlSchedule)(nil)).Elem()
}

func (i TtlScheduleArray) ToTtlScheduleArrayOutput() TtlScheduleArrayOutput {
	return i.ToTtlScheduleArrayOutputWithContext(context.Background())
}

func (i TtlScheduleArray) ToTtlScheduleArrayOutputWithContext(ctx context.Context) TtlScheduleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TtlScheduleArrayOutput)
}

// TtlScheduleMapInput is an input type that accepts TtlScheduleMap and TtlScheduleMapOutput values.
// You can construct a concrete instance of `TtlScheduleMapInput` via:
//
//	TtlScheduleMap{ "key": TtlScheduleArgs{...} }
type TtlScheduleMapInput interface {
	pulumi.Input

	ToTtlScheduleMapOutput() TtlScheduleMapOutput
	ToTtlScheduleMapOutputWithContext(context.Context) TtlScheduleMapOutput
}

type TtlScheduleMap map[string]TtlScheduleInput

func (TtlScheduleMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*TtlSchedule)(nil)).Elem()
}

func (i TtlScheduleMap) ToTtlScheduleMapOutput() TtlScheduleMapOutput {
	return i.ToTtlScheduleMapOutputWithContext(context.Background())
}

func (i TtlScheduleMap) ToTtlScheduleMapOutputWithContext(ctx context.Context) TtlScheduleMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TtlScheduleMapOutput)
}

type TtlScheduleOutput struct{ *pulumi.OutputState }

func (TtlScheduleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TtlSchedule)(nil)).Elem()
}

func (o TtlScheduleOutput) ToTtlScheduleOutput() TtlScheduleOutput {
	return o
}

func (o TtlScheduleOutput) ToTtlScheduleOutputWithContext(ctx context.Context) TtlScheduleOutput {
	return o
}

// True if the stack and all associated history and settings should be deleted.
func (o TtlScheduleOutput) DeleteAfterDestroy() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *TtlSchedule) pulumi.BoolPtrOutput { return v.DeleteAfterDestroy }).(pulumi.BoolPtrOutput)
}

// Organization name.
func (o TtlScheduleOutput) Organization() pulumi.StringOutput {
	return o.ApplyT(func(v *TtlSchedule) pulumi.StringOutput { return v.Organization }).(pulumi.StringOutput)
}

// Project name.
func (o TtlScheduleOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v *TtlSchedule) pulumi.StringOutput { return v.Project }).(pulumi.StringOutput)
}

// Schedule ID of the created schedule, assigned by Pulumi Cloud.
func (o TtlScheduleOutput) ScheduleId() pulumi.StringOutput {
	return o.ApplyT(func(v *TtlSchedule) pulumi.StringOutput { return v.ScheduleId }).(pulumi.StringOutput)
}

// Stack name.
func (o TtlScheduleOutput) Stack() pulumi.StringOutput {
	return o.ApplyT(func(v *TtlSchedule) pulumi.StringOutput { return v.Stack }).(pulumi.StringOutput)
}

// The time at which the schedule should run, in ISO 8601 format. Eg: 2020-01-01T00:00:00Z.
func (o TtlScheduleOutput) Timestamp() pulumi.StringOutput {
	return o.ApplyT(func(v *TtlSchedule) pulumi.StringOutput { return v.Timestamp }).(pulumi.StringOutput)
}

type TtlScheduleArrayOutput struct{ *pulumi.OutputState }

func (TtlScheduleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*TtlSchedule)(nil)).Elem()
}

func (o TtlScheduleArrayOutput) ToTtlScheduleArrayOutput() TtlScheduleArrayOutput {
	return o
}

func (o TtlScheduleArrayOutput) ToTtlScheduleArrayOutputWithContext(ctx context.Context) TtlScheduleArrayOutput {
	return o
}

func (o TtlScheduleArrayOutput) Index(i pulumi.IntInput) TtlScheduleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *TtlSchedule {
		return vs[0].([]*TtlSchedule)[vs[1].(int)]
	}).(TtlScheduleOutput)
}

type TtlScheduleMapOutput struct{ *pulumi.OutputState }

func (TtlScheduleMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*TtlSchedule)(nil)).Elem()
}

func (o TtlScheduleMapOutput) ToTtlScheduleMapOutput() TtlScheduleMapOutput {
	return o
}

func (o TtlScheduleMapOutput) ToTtlScheduleMapOutputWithContext(ctx context.Context) TtlScheduleMapOutput {
	return o
}

func (o TtlScheduleMapOutput) MapIndex(k pulumi.StringInput) TtlScheduleOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *TtlSchedule {
		return vs[0].(map[string]*TtlSchedule)[vs[1].(string)]
	}).(TtlScheduleOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*TtlScheduleInput)(nil)).Elem(), &TtlSchedule{})
	pulumi.RegisterInputType(reflect.TypeOf((*TtlScheduleArrayInput)(nil)).Elem(), TtlScheduleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TtlScheduleMapInput)(nil)).Elem(), TtlScheduleMap{})
	pulumi.RegisterOutputType(TtlScheduleOutput{})
	pulumi.RegisterOutputType(TtlScheduleArrayOutput{})
	pulumi.RegisterOutputType(TtlScheduleMapOutput{})
}
