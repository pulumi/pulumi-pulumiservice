// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package pulumiservice

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-pulumiservice/sdk/go/pulumiservice/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// A scheduled recurring or single time run of a pulumi command.
//
// ### Import
//
// Deployment schedules can be imported using the `id`, which for deployment schedules is `{org}/{project}/{stack}/{scheduleId}` e.g.,
//
// ```sh
//
//	$ pulumi import pulumiservice:index:DeploymentSchedule my_schedule my-org/my-project/my-stack/sched-789
//
// ```
type DeploymentSchedule struct {
	pulumi.CustomResourceState

	// Organization name.
	Organization pulumi.StringOutput `pulumi:"organization"`
	// Project name.
	Project pulumi.StringOutput `pulumi:"project"`
	// Which operation to run.
	PulumiOperation PulumiOperationOutput `pulumi:"pulumiOperation"`
	// Cron expression for recurring scheduled runs. If you are supplying this, do not supply timestamp.
	ScheduleCron pulumi.StringPtrOutput `pulumi:"scheduleCron"`
	// Schedule ID of the created schedule, assigned by Pulumi Cloud.
	ScheduleId pulumi.StringOutput `pulumi:"scheduleId"`
	// Stack name.
	Stack pulumi.StringOutput `pulumi:"stack"`
	// The time at which the schedule should run, in ISO 8601 format. Eg: 2020-01-01T00:00:00Z. If you are supplying this, do not supply scheduleCron.
	Timestamp pulumi.StringPtrOutput `pulumi:"timestamp"`
}

// NewDeploymentSchedule registers a new resource with the given unique name, arguments, and options.
func NewDeploymentSchedule(ctx *pulumi.Context,
	name string, args *DeploymentScheduleArgs, opts ...pulumi.ResourceOption) (*DeploymentSchedule, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Organization == nil {
		return nil, errors.New("invalid value for required argument 'Organization'")
	}
	if args.Project == nil {
		return nil, errors.New("invalid value for required argument 'Project'")
	}
	if args.PulumiOperation == nil {
		return nil, errors.New("invalid value for required argument 'PulumiOperation'")
	}
	if args.Stack == nil {
		return nil, errors.New("invalid value for required argument 'Stack'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource DeploymentSchedule
	err := ctx.RegisterResource("pulumiservice:index:DeploymentSchedule", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetDeploymentSchedule gets an existing DeploymentSchedule resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetDeploymentSchedule(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *DeploymentScheduleState, opts ...pulumi.ResourceOption) (*DeploymentSchedule, error) {
	var resource DeploymentSchedule
	err := ctx.ReadResource("pulumiservice:index:DeploymentSchedule", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering DeploymentSchedule resources.
type deploymentScheduleState struct {
}

type DeploymentScheduleState struct {
}

func (DeploymentScheduleState) ElementType() reflect.Type {
	return reflect.TypeOf((*deploymentScheduleState)(nil)).Elem()
}

type deploymentScheduleArgs struct {
	// Organization name.
	Organization string `pulumi:"organization"`
	// Project name.
	Project string `pulumi:"project"`
	// Which command to run.
	PulumiOperation PulumiOperation `pulumi:"pulumiOperation"`
	// Cron expression for recurring scheduled runs. If you are supplying this, do not supply timestamp.
	ScheduleCron *string `pulumi:"scheduleCron"`
	// Stack name.
	Stack string `pulumi:"stack"`
	// The time at which the schedule should run, in ISO 8601 format. Eg: 2020-01-01T00:00:00Z. If you are supplying this, do not supply scheduleCron.
	Timestamp *string `pulumi:"timestamp"`
}

// The set of arguments for constructing a DeploymentSchedule resource.
type DeploymentScheduleArgs struct {
	// Organization name.
	Organization pulumi.StringInput
	// Project name.
	Project pulumi.StringInput
	// Which command to run.
	PulumiOperation PulumiOperationInput
	// Cron expression for recurring scheduled runs. If you are supplying this, do not supply timestamp.
	ScheduleCron pulumi.StringPtrInput
	// Stack name.
	Stack pulumi.StringInput
	// The time at which the schedule should run, in ISO 8601 format. Eg: 2020-01-01T00:00:00Z. If you are supplying this, do not supply scheduleCron.
	Timestamp pulumi.StringPtrInput
}

func (DeploymentScheduleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*deploymentScheduleArgs)(nil)).Elem()
}

type DeploymentScheduleInput interface {
	pulumi.Input

	ToDeploymentScheduleOutput() DeploymentScheduleOutput
	ToDeploymentScheduleOutputWithContext(ctx context.Context) DeploymentScheduleOutput
}

func (*DeploymentSchedule) ElementType() reflect.Type {
	return reflect.TypeOf((**DeploymentSchedule)(nil)).Elem()
}

func (i *DeploymentSchedule) ToDeploymentScheduleOutput() DeploymentScheduleOutput {
	return i.ToDeploymentScheduleOutputWithContext(context.Background())
}

func (i *DeploymentSchedule) ToDeploymentScheduleOutputWithContext(ctx context.Context) DeploymentScheduleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeploymentScheduleOutput)
}

// DeploymentScheduleArrayInput is an input type that accepts DeploymentScheduleArray and DeploymentScheduleArrayOutput values.
// You can construct a concrete instance of `DeploymentScheduleArrayInput` via:
//
//	DeploymentScheduleArray{ DeploymentScheduleArgs{...} }
type DeploymentScheduleArrayInput interface {
	pulumi.Input

	ToDeploymentScheduleArrayOutput() DeploymentScheduleArrayOutput
	ToDeploymentScheduleArrayOutputWithContext(context.Context) DeploymentScheduleArrayOutput
}

type DeploymentScheduleArray []DeploymentScheduleInput

func (DeploymentScheduleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*DeploymentSchedule)(nil)).Elem()
}

func (i DeploymentScheduleArray) ToDeploymentScheduleArrayOutput() DeploymentScheduleArrayOutput {
	return i.ToDeploymentScheduleArrayOutputWithContext(context.Background())
}

func (i DeploymentScheduleArray) ToDeploymentScheduleArrayOutputWithContext(ctx context.Context) DeploymentScheduleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeploymentScheduleArrayOutput)
}

// DeploymentScheduleMapInput is an input type that accepts DeploymentScheduleMap and DeploymentScheduleMapOutput values.
// You can construct a concrete instance of `DeploymentScheduleMapInput` via:
//
//	DeploymentScheduleMap{ "key": DeploymentScheduleArgs{...} }
type DeploymentScheduleMapInput interface {
	pulumi.Input

	ToDeploymentScheduleMapOutput() DeploymentScheduleMapOutput
	ToDeploymentScheduleMapOutputWithContext(context.Context) DeploymentScheduleMapOutput
}

type DeploymentScheduleMap map[string]DeploymentScheduleInput

func (DeploymentScheduleMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*DeploymentSchedule)(nil)).Elem()
}

func (i DeploymentScheduleMap) ToDeploymentScheduleMapOutput() DeploymentScheduleMapOutput {
	return i.ToDeploymentScheduleMapOutputWithContext(context.Background())
}

func (i DeploymentScheduleMap) ToDeploymentScheduleMapOutputWithContext(ctx context.Context) DeploymentScheduleMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeploymentScheduleMapOutput)
}

type DeploymentScheduleOutput struct{ *pulumi.OutputState }

func (DeploymentScheduleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DeploymentSchedule)(nil)).Elem()
}

func (o DeploymentScheduleOutput) ToDeploymentScheduleOutput() DeploymentScheduleOutput {
	return o
}

func (o DeploymentScheduleOutput) ToDeploymentScheduleOutputWithContext(ctx context.Context) DeploymentScheduleOutput {
	return o
}

// Organization name.
func (o DeploymentScheduleOutput) Organization() pulumi.StringOutput {
	return o.ApplyT(func(v *DeploymentSchedule) pulumi.StringOutput { return v.Organization }).(pulumi.StringOutput)
}

// Project name.
func (o DeploymentScheduleOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v *DeploymentSchedule) pulumi.StringOutput { return v.Project }).(pulumi.StringOutput)
}

// Which operation to run.
func (o DeploymentScheduleOutput) PulumiOperation() PulumiOperationOutput {
	return o.ApplyT(func(v *DeploymentSchedule) PulumiOperationOutput { return v.PulumiOperation }).(PulumiOperationOutput)
}

// Cron expression for recurring scheduled runs. If you are supplying this, do not supply timestamp.
func (o DeploymentScheduleOutput) ScheduleCron() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DeploymentSchedule) pulumi.StringPtrOutput { return v.ScheduleCron }).(pulumi.StringPtrOutput)
}

// Schedule ID of the created schedule, assigned by Pulumi Cloud.
func (o DeploymentScheduleOutput) ScheduleId() pulumi.StringOutput {
	return o.ApplyT(func(v *DeploymentSchedule) pulumi.StringOutput { return v.ScheduleId }).(pulumi.StringOutput)
}

// Stack name.
func (o DeploymentScheduleOutput) Stack() pulumi.StringOutput {
	return o.ApplyT(func(v *DeploymentSchedule) pulumi.StringOutput { return v.Stack }).(pulumi.StringOutput)
}

// The time at which the schedule should run, in ISO 8601 format. Eg: 2020-01-01T00:00:00Z. If you are supplying this, do not supply scheduleCron.
func (o DeploymentScheduleOutput) Timestamp() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DeploymentSchedule) pulumi.StringPtrOutput { return v.Timestamp }).(pulumi.StringPtrOutput)
}

type DeploymentScheduleArrayOutput struct{ *pulumi.OutputState }

func (DeploymentScheduleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*DeploymentSchedule)(nil)).Elem()
}

func (o DeploymentScheduleArrayOutput) ToDeploymentScheduleArrayOutput() DeploymentScheduleArrayOutput {
	return o
}

func (o DeploymentScheduleArrayOutput) ToDeploymentScheduleArrayOutputWithContext(ctx context.Context) DeploymentScheduleArrayOutput {
	return o
}

func (o DeploymentScheduleArrayOutput) Index(i pulumi.IntInput) DeploymentScheduleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *DeploymentSchedule {
		return vs[0].([]*DeploymentSchedule)[vs[1].(int)]
	}).(DeploymentScheduleOutput)
}

type DeploymentScheduleMapOutput struct{ *pulumi.OutputState }

func (DeploymentScheduleMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*DeploymentSchedule)(nil)).Elem()
}

func (o DeploymentScheduleMapOutput) ToDeploymentScheduleMapOutput() DeploymentScheduleMapOutput {
	return o
}

func (o DeploymentScheduleMapOutput) ToDeploymentScheduleMapOutputWithContext(ctx context.Context) DeploymentScheduleMapOutput {
	return o
}

func (o DeploymentScheduleMapOutput) MapIndex(k pulumi.StringInput) DeploymentScheduleOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *DeploymentSchedule {
		return vs[0].(map[string]*DeploymentSchedule)[vs[1].(string)]
	}).(DeploymentScheduleOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*DeploymentScheduleInput)(nil)).Elem(), &DeploymentSchedule{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeploymentScheduleArrayInput)(nil)).Elem(), DeploymentScheduleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeploymentScheduleMapInput)(nil)).Elem(), DeploymentScheduleMap{})
	pulumi.RegisterOutputType(DeploymentScheduleOutput{})
	pulumi.RegisterOutputType(DeploymentScheduleArrayOutput{})
	pulumi.RegisterOutputType(DeploymentScheduleMapOutput{})
}
