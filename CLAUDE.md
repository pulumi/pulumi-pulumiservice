# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is the Pulumi Service Provider (PSP), a Pulumi provider built on top of the Pulumi Cloud REST API that allows managing Pulumi Cloud resources (Stacks, Environments, Teams, Tokens, Webhooks, Deployment Settings, etc.) using Pulumi programs.

The provider is written in Go and generates SDKs for multiple languages (Node.js/TypeScript, Python, Go, .NET, Java).

## Repository Structure

- `provider/` - Core provider implementation in Go
  - `provider/cmd/pulumi-resource-pulumiservice/` - Main provider binary and schema.json
  - `provider/pkg/provider/` - Provider server implementation (gRPC)
  - `provider/pkg/pulumiapi/` - HTTP client wrappers for Pulumi Cloud REST API
  - `provider/pkg/resources/` - Resource implementations (teams, stacks, webhooks, etc.)
  - `provider/pkg/util/` - Utility functions for property handling, diffs, secrets
- `sdk/` - Generated SDKs for each language (dotnet, go, java, nodejs, python)
- `examples/` - Example programs in various languages demonstrating provider usage

## Build Commands

### Essential Commands

```bash
# Restore/install build dependencies
make ensure

# Build provider binary only
make provider

# Build all SDKs (requires provider to be built first)
make build_sdks

# Build everything (provider + all SDKs)
make build

# Run provider tests
make test_provider

# Run linting (runs golangci-lint in provider, sdk, and examples directories)
make lint
```

### SDK-Specific Commands

```bash
make nodejs_sdk    # Build Node.js/TypeScript SDK
make python_sdk    # Build Python SDK
make go_sdk        # Build Go SDK
make dotnet_sdk    # Build .NET SDK
make java_sdk      # Build Java SDK
```

### Installation Commands

```bash
make install              # Install provider binary and Node.js/dotnet SDKs
make install_nodejs_sdk   # Link Node.js SDK locally via yarn
make install_java_sdk     # Publish Java SDK to local Maven
```

## Environment Variables

- **Integration Tests**: This project uses `.env` file for local testing credentials
  - `PULUMI_ACCESS_TOKEN`: Token for authenticating with Pulumi Cloud
  - `PULUMI_TEST_OWNER`: Organization name for tests (defaults to `service-provider-test-org` if not set)
  - These variables are loaded automatically by the test framework when present in `.env`
  - The `.env` file is gitignored for security

### Testing

```bash
# Run provider unit tests
cd provider/pkg && go test -short -v -count=1 -cover -timeout 2h -parallel 4 ./...

# Run example tests (integration tests)
cd examples && go test -tags=all -v -count=1 -timeout 3h -parallel 4

# Run specific example test
cd examples && go test -v -run TestYamlStackTagsPluralExample -tags yaml -timeout 10m
```

- Integration tests are located in `examples/` directory
- Tests are tagged: use `-tags yaml`, `-tags nodejs`, `-tags python`, etc.
- The `.env` file allows running integration tests locally against a custom organization
- Every new resource should have unit tests in `provider/pkg/` with `_test.go` suffix
- Add example programs in `examples/` for each new resource (examples serve as integration tests)
- Examples are organized by language: `ts-*`, `py-*`, `go-*`, `cs-*`, `java-*`, `yaml-*`

#### YAML Example Best Practices

When creating YAML examples, use the `${digits}` placeholder for resource names that must be unique:

```yaml
resources:
  my-resource:
    type: pulumiservice:SomeResource
    properties:
      name: my-unique-resource-${digits}
```

The test framework automatically replaces `${digits}` with a random 5-digit number generated by `generateRandomFiveDigits()`. This ensures:
- Tests don't conflict when run concurrently
- Tests can be re-run without manual cleanup
- Resource names remain unique across test runs

In your test registration, pass the digits as config:

```go
func TestYamlMyResourceExample(t *testing.T) {
    cwd := getCwd(t)
    digits := generateRandomFiveDigits()
    integration.ProgramTest(t, &integration.ProgramTestOptions{
        Dir: path.Join(cwd, ".", "yaml-my-resource"),
        Config: map[string]string{
            "digits": digits,
        },
    })
}
```

**Example**: See `examples/yaml-role/Pulumi.yaml` and `examples/examples_yaml_test.go` for reference implementations.

## Development Workflow

### Copyright Headers

**IMPORTANT**: All new files must have correct copyright year ranges:
- In 2025: Use `// Copyright 2016-2025, Pulumi Corporation.`
- In 2026: Use `// Copyright 2016-2026, Pulumi Corporation.`
- General rule: Always use current year as the end year for new files

### CHANGELOG Updates

**IMPORTANT**: Always update `CHANGELOG.md` when making code changes that affect users:

1. Add an entry under the `## Unreleased` section
2. If `## Unreleased` doesn't exist, create it at the top of the file (after the `# CHANGELOG` header)
3. Categorize changes appropriately:
   - `### Improvements` - New features, enhancements, new resources
   - `### Bug Fixes` - Bug fixes, corrections
   - `### Breaking Changes` - Breaking changes (rare, requires major version bump)
4. Format: `- Description of change [#issue_or_pr_number](link_to_issue_or_pr)`
5. Examples:
   - `- Added StackTags resource for managing multiple stack tags [#61](https://github.com/pulumi/pulumi-pulumiservice/issues/61)`
   - `- Fixed OIDC Issuer policies order to prevent accidental drifts [#542](https://github.com/pulumi/pulumi-pulumiservice/pull/542)`

### Schema Changes

The provider schema is **manually maintained** at `provider/cmd/pulumi-resource-pulumiservice/schema.json`. When adding/modifying resources:

1. Update `schema.json` with the new resource/property definitions
2. Run `make provider` to regenerate the provider binary (uses `go generate`)
3. Run `make build_sdks` to regenerate all language SDKs from the schema
4. The schema is embedded into the provider binary at build time

#### Schema Best Practices for Flexible/Dynamic Properties

When defining properties that need to accept arbitrary nested structures (like polymorphic types or free-form objects), **DO NOT** use `"additionalProperties": true`. This will cause SDK generation to fail with:

```
json: cannot unmarshal bool into Go struct field PropertySpec.TypeSpec.additionalProperties of type schema.TypeSpec
```

Instead, use the `pulumi.json#/Any` reference:

```json
{
  "propertyName": {
    "description": "Description of the flexible property",
    "$ref": "pulumi.json#/Any"
  }
}
```

This allows the property to accept any value type while generating correct SDK code across all languages. Example: see `details` property in the `Role` resource schema.

### Adding a New Resource

1. Add resource definition to `provider/cmd/pulumi-resource-pulumiservice/schema.json`
2. Create API client methods in `provider/pkg/pulumiapi/` (e.g., `teams.go`, `webhooks.go`)
3. Create resource implementation in `provider/pkg/resources/` implementing `PulumiServiceResource` interface
4. Register the resource in `provider/pkg/provider/provider.go`
5. Rebuild provider and SDKs: `make build`
6. Add examples in `examples/` directory
7. **IMPORTANT**: Always create a YAML example for the new resource:
   - Add a `yaml-*` example directory in `examples/`
   - Create a `README.md` in the example directory that includes a link to the `pulumi convert` documentation (https://www.pulumi.com/docs/iac/cli/commands/pulumi_convert/) for converting the example to other programming languages
   - Register the example test in `examples/examples_yaml_test.go`
   - Test the YAML example before completing: `cd examples && go test -v -run TestYaml<ResourceName>Example -tags yaml -timeout 10m`

### Resource Interface

All resources must implement the `PulumiServiceResource` interface:

```go
type PulumiServiceResource interface {
    Diff(req *pulumirpc.DiffRequest) (*pulumirpc.DiffResponse, error)
    Create(req *pulumirpc.CreateRequest) (*pulumirpc.CreateResponse, error)
    Delete(req *pulumirpc.DeleteRequest) (*pbempty.Empty, error)
    Check(req *pulumirpc.CheckRequest) (*pulumirpc.CheckResponse, error)
    Update(req *pulumirpc.UpdateRequest) (*pulumirpc.UpdateResponse, error)
    Read(req *pulumirpc.ReadRequest) (*pulumirpc.ReadResponse, error)
    Name() string
}
```

### Handling Flexible/Dynamic Properties in Resources

When a resource needs to accept and return flexible map structures (e.g., for polymorphic API types or arbitrary nested objects), you need to convert between Pulumi's `resource.PropertyMap` and Go's `map[string]interface{}`.

Create helper functions in your resource file:

```go
// mapToPropertyValue converts a map[string]interface{} to a resource.PropertyValue
func mapToPropertyValue(m map[string]interface{}) resource.PropertyValue {
    pm := resource.PropertyMap{}
    for k, v := range m {
        pm[resource.PropertyKey(k)] = interfaceToPropertyValue(v)
    }
    return resource.NewPropertyValue(pm)
}

// propertyValueToMap converts a resource.PropertyValue to a map[string]interface{}
func propertyValueToMap(pv resource.PropertyValue) map[string]interface{} {
    if !pv.IsObject() {
        return nil
    }
    result := make(map[string]interface{})
    for k, v := range pv.ObjectValue() {
        result[string(k)] = propertyValueToInterface(v)
    }
    return result
}

// interfaceToPropertyValue handles all Go types recursively
func interfaceToPropertyValue(v interface{}) resource.PropertyValue {
    switch val := v.(type) {
    case bool:
        return resource.NewPropertyValue(val)
    case float64:
        return resource.NewPropertyValue(val)
    case string:
        return resource.NewPropertyValue(val)
    case []interface{}:
        arr := []resource.PropertyValue{}
        for _, item := range val {
            arr = append(arr, interfaceToPropertyValue(item))
        }
        return resource.NewPropertyValue(arr)
    case map[string]interface{}:
        return mapToPropertyValue(val)
    case nil:
        return resource.NewNullProperty()
    default:
        return resource.NewPropertyValue(fmt.Sprintf("%v", val))
    }
}

// propertyValueToInterface converts back to interface{}
func propertyValueToInterface(pv resource.PropertyValue) interface{} {
    if pv.IsBool() {
        return pv.BoolValue()
    }
    if pv.IsNumber() {
        return pv.NumberValue()
    }
    if pv.IsString() {
        return pv.StringValue()
    }
    if pv.IsArray() {
        arr := []interface{}{}
        for _, item := range pv.ArrayValue() {
            arr = append(arr, propertyValueToInterface(item))
        }
        return arr
    }
    if pv.IsObject() {
        return propertyValueToMap(pv)
    }
    if pv.IsNull() {
        return nil
    }
    return ""
}
```

**Example**: See `provider/pkg/resources/role.go` for a complete implementation of this pattern.

## API Client Architecture

The `pulumiapi` package provides HTTP client wrappers for the Pulumi Cloud REST API:

- `Client` - Base HTTP client with authentication and standard headers
- Individual files for each resource type (e.g., `teams.go`, `stack.go`, `webhooks.go`)
- All API calls use the standard headers: `X-Pulumi-Source: provider`, `Accept: application/vnd.pulumi+8`
- Authentication via Bearer token in `Authorization` header

## Release Process

Releases are handled by Pulumi employees via `#release-ops` Slack channel. GitHub Actions automatically builds, tests, and publishes new releases to all package managers.

## Configuration

Provider accepts two configuration options:
- `accessToken` (env: `PULUMI_ACCESS_TOKEN`) - Pulumi Service access token
- `apiUrl` (env: `PULUMI_BACKEND_URL`) - Custom API URL for self-hosted instances

## Version Management

- Provider version is set via `PROVIDER_VERSION` environment variable or defaults to `1.0.0-alpha.0+dev`
- Version is injected into provider binary via LDFLAGS at build time
- The Pulumi CLI binary version used for SDK generation is automatically synced with the `github.com/pulumi/pulumi/pkg/v3` dependency version

## Linting

The Makefile references `.golangci.yml` but it may not exist in the repository root. The `make lint` command runs golangci-lint in three directories: `provider`, `sdk`, and `examples` with a 10-minute timeout.

**Important**: When linting the `examples/` directory, you must use the `--build-tags all` flag because the test files use build tags (yaml, nodejs, python, etc.):

```bash
cd examples && golangci-lint run --timeout 10m --build-tags all
```

Without the build tags, golangci-lint may report false positives about unused functions that are actually used in files with specific build tags.

## Debugging CI Failures

When investigating CI test failures:

1. **Use GitHub CLI to fetch logs**:
   ```bash
   gh run view <run_id> --log-failed
   gh api repos/pulumi/pulumi-pulumiservice/actions/jobs/<job_id>/logs | grep "error:"
   ```

2. **Check for API validation errors**: The Pulumi Cloud API may reject values that are defined in the schema but not yet implemented (e.g., "runner" token type in OIDC policies)

3. **Check for outdated test data**: Examples may contain hardcoded values like TLS certificate thumbprints that become stale when certificates are rotated

4. **Look for related issues across examples**: If one language example fails, check all language examples (ts-, py-, go-, cs-, yaml-) for the same issue
